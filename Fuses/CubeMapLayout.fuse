--- Implements different layouts for a cube map.
--
-- See for example https://docs.unity3d.com/Manual/class-Cubemap.html or https://github.com/Microsoft/DirectXTex/wiki/Texassemble
-- for the horizontal/vertical cross/strip layouts.
-- See https://tools.bivrost360.com/webplayer-docs/cubemap-facebook.html or https://www.researchgate.net/figure/360-video-projected-as-a-cubemap-Order-of-cube-faces-from-top-left-to-bottom-right-are_fig2_316914613
-- for the Facebook format.
--
-- Maybe a T: https://www.researchgate.net/figure/The-cube-map-generated-by-projecting-the-surrounding-point-cloud-onto-6-faces-of-a-cube_fig2_338879396
--
-- https://renderman.pixar.com/resources/RenderMan_20/ptexture.html
-- https://docs.unrealengine.com/4.27/en-US/RenderingAndGraphics/Textures/Cubemaps/CreatingCubemaps/
-- https://rmanwiki.pixar.com/display/REN24/txmake
--
-- https://community.khronos.org/t/image-orientation-for-cubemaps-actually-a-very-old-topic/105338
-- https://stackoverflow.com/questions/11685608/convention-of-faces-in-opengl-cubemapping


-- ----------------------------------------------------------------------------------------------------------------------------------------

FuRegisterClass("CubeMapLayout_nmbr73", CT_SourceTool, {
    REGS_Name = "CubeMap Layout",
	  REGS_Category = "Fuses\\Kernfusion",
    REGS_OpDescription = "Different layouts for the six faces of a cube map",
	  REGS_OpIconString = "CML",
    REG_Source_GlobalCtrls = true,
    REG_Source_SizeCtrls = true,
    REG_Source_AspectCtrls = true,
    REG_Source_DepthCtrls = true,
	  REG_TimeVariant = false,
    -- REGS_IconID = "Icons.Tools.Icons.Layout",
    REGS_Company = "nmbr73",
	  REGS_URL = "https://nmbr73.github.io/",
	  REG_Version	= 000001,
    REG_Fuse_NoEdit = true,
    REG_Fuse_NoReload = false,
    })


-------------------------------------------------------------------------------------------------------------------------------------------
-- Callback to initialize the tool.
--
function Create()


  local layouts = {
    { MBTNC_AddButton = "Horizontal Cross (Pixar)", MBTNCD_ButtonWidth = 1, MBTNCS_ToolTip = "Horizontal Cross (Pixar)"         },
    { MBTNC_AddButton = "Vertical Cross",           MBTNCD_ButtonWidth = 1, MBTNCS_ToolTip = "Vertical Cross",                  },
    { MBTNC_AddButton = "Row (UE4)",                MBTNCD_ButtonWidth = 0.5, MBTNCS_ToolTip = "Row / Horizontal Strip (NVIDIA / Unreal Engine 4)"  },
    { MBTNC_AddButton = "Column (OpenEXR)",         MBTNCD_ButtonWidth = 0.5, MBTNCS_ToolTip = "Column / Vertical Strip (OpenEXR)" },
    { MBTNC_AddButton = "Horizontal T",             MBTNCD_ButtonWidth = 0.5, MBTNCS_ToolTip = "Horizontal T",                    },
    { MBTNC_AddButton = "Vertical T",               MBTNCD_ButtonWidth = 0.5, MBTNCS_ToolTip = "Vertical T",                      },
    { MBTNC_AddButton = "3x2 (TIFF)",               MBTNCD_ButtonWidth = 0.5, MBTNCS_ToolTip = "TIFF",                            },
    { MBTNC_AddButton = "3x2 (Facebook)",           MBTNCD_ButtonWidth = 0.5, MBTNCS_ToolTip = "Facebook",                        },
  }

  InLayout = self:AddInput("Input Layout", "FromLayout", {
    INPID_InputControl = "MultiButtonControl",
    LINKID_DataType = "Number",
    INP_Default = 0,
    -- MBTNC_ForceButtons = true,
    -- IC_NoLabel = true,
    IC_NoReset = true,
    layouts
  })


  OutLayout = self:AddInput("Output Layout", "ToLayout", {
    INPID_InputControl = "MultiButtonControl",
    LINKID_DataType = "Number",
    INP_Default = 0,
    -- MBTNC_ForceButtons = true,
    -- IC_NoLabel = true,
    IC_NoReset = true,

    layouts,

    { MBTNC_AddButton = "Face 0 / +X / right",      MBTNCD_ButtonWidth = 0.5, MBTNCS_ToolTip = "Right (Positive X; Index 0)",     },
    { MBTNC_AddButton = "Face 1 / -X / left",       MBTNCD_ButtonWidth = 0.5, MBTNCS_ToolTip = "Left (Negative X; Index 1)",      },
    { MBTNC_AddButton = "Face 2 / +Y / top",        MBTNCD_ButtonWidth = 0.5, MBTNCS_ToolTip = "Top (Positive Y; Index 2)",       },
    { MBTNC_AddButton = "Face 3 / -Y / bottom",     MBTNCD_ButtonWidth = 0.5, MBTNCS_ToolTip = "Bottom (Negative Y; Index 3)",    },
    { MBTNC_AddButton = "Face 4 / +Z / front",      MBTNCD_ButtonWidth = 0.5, MBTNCS_ToolTip = "Front (Positive Z; Index 4)",     },
    { MBTNC_AddButton = "Face 5 / -Z / back",       MBTNCD_ButtonWidth = 0.5, MBTNCS_ToolTip = "Back (Negative Z; Index 5)",      },

  })


  InImage   = self:AddInput( "Input",  "Input",  {
    LINKID_DataType = "Image",
    LINK_Main = 1,
    INP_Required = false
  })

  OutImage  = self:AddOutput( "Output", "Output", {
    LINKID_DataType = "Image",
    LINK_Main = 1
  })

end


-------------------------------------------------------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------------------------------------------------------------
-- Callback to render the node.
--
function Process(req)

  local w = Width
  local h = Height
  local fw = Width  / 4
  local fh = Height / 3
  local ax = XAspect
  local ay = YAspect
  local sd = SourceDepth


  local input_image   = InImage:GetValue(req)

  if input_image == nil then
    OutImage:Set(req,nil)
    return
  end

  local input_layout  = InLayout:GetValue(req).Value
  local output_layout = OutLayout:GetValue(req).Value








  if input_image ~= nil then

    fw = input_image.Width  / 4
    fh = input_image.Height / 3

    if output_layout < 6 then
      -- single face
      w = fw
      h = fh
    elseif output_layout == 6 then
      -- horizontal cross
      w = input_image.Width
      h = input_image.Height
    elseif output_layout == 7 then
      -- vertical cross
      w = fw * 3
      h = fh * 4
    elseif output_layout == 8 then
      -- horizontal strip
      w = fw * 6
      h = fh
    elseif output_layout == 9 then
      -- vertical strip
      w = fw
      h = fh * 6
    end

  end

  local face = {}

  face[0]=Image({

    IMG_Document = self.Comp,
    { IMG_Channel = "Red", },
    { IMG_Channel = "Green", },
    { IMG_Channel = "Blue", },
    { IMG_Channel = "Alpha", },
    IMG_Width  = fw,
    IMG_Height = fh,
    IMG_XScale = ax,
    IMG_YScale = ay,
    IMG_Quality = not req:IsQuick(),
    IMG_MotionBlurQuality = not req:IsNoMotionBlur(),
    IMG_DeferAlloc = true,
    IMG_ProxyScale = ( (not req:IsStampOnly()) and 1 or nil),
    IMG_Depth = ( (sd~=0) and sd or nil   )
  })

  face[0]:Fill(Pixel({R=0,G=0,B=0,A=0}))

  for i = 1,5 do
    face[i]=Image({IMG_Like = face[0], })
  end

  input_image:Crop(face[0], { CROP_XOffset  = fw*2, CROP_YOffset  = fh, CROP_Width    = fw, CROP_Height   = fh, })
  input_image:Crop(face[1], { CROP_XOffset  = 0, CROP_YOffset  = fh, CROP_Width    = fw, CROP_Height   = fh, })
  input_image:Crop(face[2], { CROP_XOffset  = fw, CROP_YOffset  = fh*2, CROP_Width    = fw, CROP_Height   = fh, })
  input_image:Crop(face[3], { CROP_XOffset  = fw, CROP_YOffset  = 0, CROP_Width    = fw, CROP_Height   = fh, })
  input_image:Crop(face[4], { CROP_XOffset  = fw, CROP_YOffset  = fh, CROP_Width    = fw, CROP_Height   = fh, })
  input_image:Crop(face[5], { CROP_XOffset  = fw*3, CROP_YOffset  = fh, CROP_Width    = fw, CROP_Height   = fh, })



  local output_image = Image({

    IMG_Document = self.Comp,
    { IMG_Channel = "Red", },
    { IMG_Channel = "Green", },
    { IMG_Channel = "Blue", },
    { IMG_Channel = "Alpha", },
    IMG_Width  = w,
    IMG_Height = h,
    IMG_XScale = ax,
    IMG_YScale = ay,
    IMG_Quality = not req:IsQuick(),
    IMG_MotionBlurQuality = not req:IsNoMotionBlur(),
    IMG_DeferAlloc = true,
    IMG_ProxyScale = ( (not req:IsStampOnly()) and 1 or nil),
    IMG_Depth = ( (sd~=0) and sd or nil   )

  })

  output_image:Fill(Pixel({R=0,G=0,B=0,A=0}))


  if req:IsPreCalc() or input_image == nil then
    output_image = Image({IMG_Like = output_image, IMG_NoData = true})
  end


  if output_layout == 6 then
    -- horizontal cross

    output_image:OMerge(face[0], fw*2, fh)
    output_image:OMerge(face[1], 0, fh)
    output_image:OMerge(face[2], fw, fh*2)
    output_image:OMerge(face[3], fw, 0)
    output_image:OMerge(face[4], fw, fh)
    output_image:OMerge(face[5], fw*3, fh)

  elseif output_layout == 7 then
    -- vertical cross


    local rotate={
      XF_XOffset  = 0.5,    XF_YOffset  = 0.5,
      XF_XAxis    = 0.5,    XF_YAxis    = 0.5,
      XF_XSize    = 1.0,    XF_YSize    = 1.0,
      XF_EdgeMode = 'Black',
      XF_Angle    = 180.0,
    }

    output_image:OMerge(face[0], fw*2, fh*2)
    output_image:OMerge(face[1], 0,      fh*2)
    output_image:OMerge(face[2], fw, fh*3)
    output_image:OMerge(face[3], fw, fh)
    output_image:OMerge(face[4], fw, fh*2)
    output_image:OMerge(face[5]:Transform(nil, rotate), fw, 0)



  end




  if output_layout < 6 then

    output_image = face[output_layout]

  end

  OutImage:Set(req,output_image)

end
