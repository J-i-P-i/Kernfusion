--- Implements different layouts for a cube map.
--
-- See for example https://docs.unity3d.com/Manual/class-Cubemap.html or https://github.com/Microsoft/DirectXTex/wiki/Texassemble
-- for the horizontal/vertical cross/strip layouts.
-- See https://tools.bivrost360.com/webplayer-docs/cubemap-facebook.html or https://www.researchgate.net/figure/360-video-projected-as-a-cubemap-Order-of-cube-faces-from-top-left-to-bottom-right-are_fig2_316914613
-- for the Facebook format.
--
-- Maybe a T: https://www.researchgate.net/figure/The-cube-map-generated-by-projecting-the-surrounding-point-cloud-onto-6-faces-of-a-cube_fig2_338879396
--
-- https://renderman.pixar.com/resources/RenderMan_20/ptexture.html
-- https://docs.unrealengine.com/4.27/en-US/RenderingAndGraphics/Textures/Cubemaps/CreatingCubemaps/
-- https://rmanwiki.pixar.com/display/REN24/txmake
--
-- https://community.khronos.org/t/image-orientation-for-cubemaps-actually-a-very-old-topic/105338
-- https://stackoverflow.com/questions/11685608/convention-of-faces-in-opengl-cubemapping


-- ----------------------------------------------------------------------------------------------------------------------------------------

FuRegisterClass("CubeMapLayout_nmbr73", CT_SourceTool, {
    REGS_Name = "CubeMap Layout",
	  REGS_Category = "Fuses\\Kernfusion",
    REGS_OpDescription = "Different layouts for the six faces of a cube map",
	  REGS_OpIconString = "CML",
    REG_Source_GlobalCtrls = true,
    REG_Source_SizeCtrls = true,
    REG_Source_AspectCtrls = true,
    REG_Source_DepthCtrls = true,
	  REG_TimeVariant = false,
    -- REGS_IconID = "Icons.Tools.Icons.Layout",
    REGS_Company = "nmbr73",
	  REGS_URL = "https://nmbr73.github.io/",
	  REG_Version	= 000001,
    REG_Fuse_NoEdit = true,
    REG_Fuse_NoReload = false,
    })


-------------------------------------------------------------------------------------------------------------------------------------------
-- Callback to initialize the tool.
--
function Create()


  local layouts = {
    { MBTNC_AddButton = "Horizontal Cross (Pixar)", MBTNCD_ButtonWidth = 1, MBTNCS_ToolTip = "Horizontal Cross (Pixar)"         },
    { MBTNC_AddButton = "Vertical Cross",           MBTNCD_ButtonWidth = 1, MBTNCS_ToolTip = "Vertical Cross",                  },
    { MBTNC_AddButton = "Row (UE4)",                MBTNCD_ButtonWidth = 0.5, MBTNCS_ToolTip = "Row / Horizontal Strip (NVIDIA / Unreal Engine 4)"  },
    { MBTNC_AddButton = "Column (OpenEXR)",         MBTNCD_ButtonWidth = 0.5, MBTNCS_ToolTip = "Column / Vertical Strip (OpenEXR)" },
    { MBTNC_AddButton = "Horizontal T",             MBTNCD_ButtonWidth = 0.5, MBTNCS_ToolTip = "Horizontal T",                    },
    { MBTNC_AddButton = "Vertical T",               MBTNCD_ButtonWidth = 0.5, MBTNCS_ToolTip = "Vertical T",                      },
    { MBTNC_AddButton = "3x2 (TIFF)",               MBTNCD_ButtonWidth = 0.5, MBTNCS_ToolTip = "TIFF",                            },
    { MBTNC_AddButton = "3x2 (Facebook)",           MBTNCD_ButtonWidth = 0.5, MBTNCS_ToolTip = "Facebook",                        },
  }

  InLayout = self:AddInput("Input Layout", "FromLayout", {
    INPID_InputControl = "MultiButtonControl",
    LINKID_DataType = "Number",
    INP_Default = 0,
    -- MBTNC_ForceButtons = true,
    -- IC_NoLabel = true,
    IC_NoReset = true,
    layouts
  })


  OutLayout = self:AddInput("Output Layout", "ToLayout", {
    INPID_InputControl = "MultiButtonControl",
    LINKID_DataType = "Number",
    INP_Default = 0,
    -- MBTNC_ForceButtons = true,
    -- IC_NoLabel = true,
    IC_NoReset = true,

    layouts,

    { MBTNC_AddButton = "Face 0 / +X / right",      MBTNCD_ButtonWidth = 0.5, MBTNCS_ToolTip = "Right (Positive X; Index 0)",     },
    { MBTNC_AddButton = "Face 1 / -X / left",       MBTNCD_ButtonWidth = 0.5, MBTNCS_ToolTip = "Left (Negative X; Index 1)",      },
    { MBTNC_AddButton = "Face 2 / +Y / top",        MBTNCD_ButtonWidth = 0.5, MBTNCS_ToolTip = "Top (Positive Y; Index 2)",       },
    { MBTNC_AddButton = "Face 3 / -Y / bottom",     MBTNCD_ButtonWidth = 0.5, MBTNCS_ToolTip = "Bottom (Negative Y; Index 3)",    },
    { MBTNC_AddButton = "Face 4 / +Z / front",      MBTNCD_ButtonWidth = 0.5, MBTNCS_ToolTip = "Front (Positive Z; Index 4)",     },
    { MBTNC_AddButton = "Face 5 / -Z / back",       MBTNCD_ButtonWidth = 0.5, MBTNCS_ToolTip = "Back (Negative Z; Index 5)",      },

  })


  InImage   = self:AddInput( "Input",  "Input",  {
    LINKID_DataType = "Image",
    LINK_Main = 1,
    INP_Required = false
  })

  OutImage  = self:AddOutput( "Output", "Output", {
    LINKID_DataType = "Image",
    LINK_Main = 1
  })

end


-------------------------------------------------------------------------------------------------------------------------------------------

  SIZE_DIVISORS = { [0] =
    { w = 4, h = 3 }, -- 0 Horizontal Cross (Pixar)
    { w = 3, h = 4 }, -- 1 Vertical Cross
    { w = 6, h = 1 }, -- 2 Row (UE4)
    { w = 1, h = 6 }, -- 3 Column (OpenEXR)
    { w = 4, h = 3 }, -- 4 Horizontal T
    { w = 3, h = 4 }, -- 5 Vertical T
    { w = 3, h = 2 }, -- 6 3x2 (TIFF)
    { w = 3, h = 2 }, -- 7 3x2 (Facebook)
  }


  CROP_OFFSETS = { [0] =
    -- 0 Horizontal Cross (Pixar)
    { [0] =
      { x = 2, y = 1 },   -- face 0
      { x = 0, y = 1 },   -- face 1
      { x = 1, y = 2 },   -- face 2
      { x = 1, y = 0 },   -- face 3
      { x = 1, y = 1 },   -- face 4
      { x = 3, y = 1 },   -- face 5
    },
    -- 1 Vertical Cross
    { [0] =
      { x = 2, y = 1 },   -- face 0
      { x = 0, y = 1 },   -- face 1
      { x = 1, y = 2 },   -- face 2
      { x = 1, y = 0 },   -- face 3
      { x = 1, y = 1 },   -- face 4
      { x = 1, y = 3 },   -- face 5
    },
    -- 2 Row (UE4)
    { [0] =
      { x = 0, y = 0 },   -- face 0
      { x = 1, y = 0 },   -- face 1
      { x = 2, y = 0 },   -- face 2
      { x = 3, y = 0 },   -- face 3
      { x = 4, y = 0 },   -- face 4
      { x = 5, y = 0 },   -- face 5
    },
    -- 3 Column (OpenEXR)
    { [0] =
      { x = 0, y = 0 },   -- face 0
      { x = 0, y = 1 },   -- face 1
      { x = 0, y = 2 },   -- face 2
      { x = 0, y = 3 },   -- face 3
      { x = 0, y = 4 },   -- face 4
      { x = 0, y = 5 },   -- face 5
    },
    -- 4 Horizontal T
    { [0] =
      { x = 2, y = 1 },   -- face 0
      { x = 0, y = 1 },   -- face 1
      { x = 0, y = 2 },   -- face 2
      { x = 0, y = 0 },   -- face 3
      { x = 1, y = 1 },   -- face 4
      { x = 3, y = 1 },   -- face 5
    },
    -- 5 Vertical T
    { [0] =
      { x = 2, y = 0 },   -- face 0
      { x = 0, y = 0 },   -- face 1
      { x = 1, y = 2 },   -- face 2
      { x = 1, y = 0 },   -- face 3
      { x = 1, y = 1 },   -- face 4
      { x = 1, y = 3 },   -- face 5
    },
    -- 6 3x2 (TIFF)
    { [0] =
      { x = 0, y = 0 },   -- face 0
      { x = 0, y = 1 },   -- face 1
      { x = 1, y = 0 },   -- face 2
      { x = 1, y = 1 },   -- face 3
      { x = 2, y = 0 },   -- face 4
      { x = 2, y = 1 },   -- face 5
    },
    -- 7 3x2 (Facebook)
    { [0] =
      { x = 0, y = 0 },   -- face 0
      { x = 1, y = 0 },   -- face 1
      { x = 2, y = 0 },   -- face 2
      { x = 0, y = 1 },   -- face 3
      { x = 1, y = 1 },   -- face 4
      { x = 2, y = 1 },   -- face 5
    },
  }


-------------------------------------------------------------------------------------------------------------------------------------------
-- Callback to render the node.
--
function Process(req)


  local input_image   = InImage:GetValue(req)

  if input_image == nil then
    print("no input connected")
    OutImage:Set(req,nil)
    return
  end


  local input_layout  = InLayout:GetValue(req).Value




  local face_width  =  input_image.Width  / SIZE_DIVISORS[input_layout]['w']
  local face_height =  input_image.Height / SIZE_DIVISORS[input_layout]['h']

  -- if input_layout == 0 or input_layout == 4 then
  --   -- horizontal cross or T
  --   face_width = input_image.Width  / 4
  --   face_height = input_image.Height  / 3
  -- elseif input_layout == 1 or input_layout == 5 then
  --   -- vertical cross or T
  --   face_width = input_image.Width  / 3
  --   face_height = input_image.Height  / 4
  -- elseif input_layout == 6 or input_layout == 7 then
  --   -- 3x2 tiff or fb
  --   face_width = input_image.Width  / 3
  --   face_height = input_image.Height  / 2
  -- elseif input_layout == 2 then
  --   -- row
  --   face_width = input_image.Width  / 6
  --   face_height = input_image.Height
  -- elseif input_layout == 7 then
  --   -- col
  --   face_width = input_image.Width
  --   face_height = input_image.Height / 6
  -- else
  --   print("unknown input layout "..input_layout)
  --   OutImage:Set(req,nil)
  --   return
  -- end

  if face_width ~= face_height then
    print("face width and height must be equal (wxh = "..face_width.."x"..face_height..")")
    OutImage:Set(req,nil)
    return
  end






  local face = {}

  for i = 0,5 do

    face[i]=Image({
      IMG_Document = self.Comp,
      { IMG_Channel = "Red", },
      { IMG_Channel = "Green", },
      { IMG_Channel = "Blue", },
      { IMG_Channel = "Alpha", },
      IMG_Width  = face_width,
      IMG_Height = face_height,
      -- IMG_XScale = 1.0,
      -- IMG_YScale = 1.0,
      -- IMG_Quality = not req:IsQuick(),
      -- IMG_MotionBlurQuality = not req:IsNoMotionBlur(),
      IMG_DeferAlloc = true,
      -- IMG_ProxyScale = ( (not req:IsStampOnly()) and 1 or nil),
      -- IMG_Depth = ( (sd~=0) and sd or nil   )
    })

    input_image:Crop(face[i], {
      CROP_XOffset  = face_width * CROP_OFFSETS[input_layout][i]['x'],
      CROP_YOffset  = face_height * CROP_OFFSETS[input_layout][i]['y'],
      CROP_Width    = face_width,
      CROP_Height   = face_height,
    })

  end




  -- input_image:Crop(face[0], { CROP_XOffset = face_width*2,  CROP_YOffset = face_height,    CROP_Width = face_width,  CROP_Height = face_height, })
  -- input_image:Crop(face[1], { CROP_XOffset = 0,             CROP_YOffset = face_height,    CROP_Width = face_width,  CROP_Height = face_height, })
  -- input_image:Crop(face[2], { CROP_XOffset = face_width,    CROP_YOffset = face_height*2,  CROP_Width = face_width,  CROP_Height = face_height, })
  -- input_image:Crop(face[3], { CROP_XOffset = face_width,    CROP_YOffset = 0,              CROP_Width = face_width,  CROP_Height = face_height, })
  -- input_image:Crop(face[4], { CROP_XOffset = face_width,    CROP_YOffset = face_height,    CROP_Width = face_width,  CROP_Height = face_height, })
  -- input_image:Crop(face[5], { CROP_XOffset = face_width*3,  CROP_YOffset = face_height,    CROP_Width = face_width,  CROP_Height = face_height, })










  if input_layout == 0 then
    -- horizontal cross

    local fw  = Width  / 4
    local fh  = Height / 3




  elseif input_layout == 0 then
  end






  local output_layout = OutLayout:GetValue(req).Value




  local w   = Width
  local h   = Height
  local fw  = Width  / 4
  local fh  = Height / 3
  local ax  = XAspect
  local ay  = YAspect
  local sd  = SourceDepth







  if input_image ~= nil then

    fw = input_image.Width  / 4
    fh = input_image.Height / 3

    if output_layout < 6 then
      -- single face
      w = fw
      h = fh
    elseif output_layout == 6 then
      -- horizontal cross
      w = input_image.Width
      h = input_image.Height
    elseif output_layout == 7 then
      -- vertical cross
      w = fw * 3
      h = fh * 4
    elseif output_layout == 8 then
      -- horizontal strip
      w = fw * 6
      h = fh
    elseif output_layout == 9 then
      -- vertical strip
      w = fw
      h = fh * 6
    end

  end

  local face = {}

  face[0]=Image({

    IMG_Document = self.Comp,
    { IMG_Channel = "Red", },
    { IMG_Channel = "Green", },
    { IMG_Channel = "Blue", },
    { IMG_Channel = "Alpha", },
    IMG_Width  = fw,
    IMG_Height = fh,
    IMG_XScale = ax,
    IMG_YScale = ay,
    IMG_Quality = not req:IsQuick(),
    IMG_MotionBlurQuality = not req:IsNoMotionBlur(),
    IMG_DeferAlloc = true,
    IMG_ProxyScale = ( (not req:IsStampOnly()) and 1 or nil),
    IMG_Depth = ( (sd~=0) and sd or nil   )
  })

  face[0]:Fill(Pixel({R=0,G=0,B=0,A=0}))

  for i = 1,5 do
    face[i]=Image({IMG_Like = face[0], })
  end

  input_image:Crop(face[0], { CROP_XOffset  = fw*2, CROP_YOffset  = fh, CROP_Width    = fw, CROP_Height   = fh, })
  input_image:Crop(face[1], { CROP_XOffset  = 0, CROP_YOffset  = fh, CROP_Width    = fw, CROP_Height   = fh, })
  input_image:Crop(face[2], { CROP_XOffset  = fw, CROP_YOffset  = fh*2, CROP_Width    = fw, CROP_Height   = fh, })
  input_image:Crop(face[3], { CROP_XOffset  = fw, CROP_YOffset  = 0, CROP_Width    = fw, CROP_Height   = fh, })
  input_image:Crop(face[4], { CROP_XOffset  = fw, CROP_YOffset  = fh, CROP_Width    = fw, CROP_Height   = fh, })
  input_image:Crop(face[5], { CROP_XOffset  = fw*3, CROP_YOffset  = fh, CROP_Width    = fw, CROP_Height   = fh, })



  local output_image = Image({

    IMG_Document = self.Comp,
    { IMG_Channel = "Red", },
    { IMG_Channel = "Green", },
    { IMG_Channel = "Blue", },
    { IMG_Channel = "Alpha", },
    IMG_Width  = w,
    IMG_Height = h,
    IMG_XScale = ax,
    IMG_YScale = ay,
    IMG_Quality = not req:IsQuick(),
    IMG_MotionBlurQuality = not req:IsNoMotionBlur(),
    IMG_DeferAlloc = true,
    IMG_ProxyScale = ( (not req:IsStampOnly()) and 1 or nil),
    IMG_Depth = ( (sd~=0) and sd or nil   )

  })

  output_image:Fill(Pixel({R=0,G=0,B=0,A=0}))


  if req:IsPreCalc() or input_image == nil then
    output_image = Image({IMG_Like = output_image, IMG_NoData = true})
  end


  if output_layout == 6 then
    -- horizontal cross

    output_image:OMerge(face[0], fw*2, fh)
    output_image:OMerge(face[1], 0, fh)
    output_image:OMerge(face[2], fw, fh*2)
    output_image:OMerge(face[3], fw, 0)
    output_image:OMerge(face[4], fw, fh)
    output_image:OMerge(face[5], fw*3, fh)

  elseif output_layout == 7 then
    -- vertical cross


    local rotate={
      XF_XOffset  = 0.5,    XF_YOffset  = 0.5,
      XF_XAxis    = 0.5,    XF_YAxis    = 0.5,
      XF_XSize    = 1.0,    XF_YSize    = 1.0,
      XF_EdgeMode = 'Black',
      XF_Angle    = 180.0,
    }

    output_image:OMerge(face[0], fw*2, fh*2)
    output_image:OMerge(face[1], 0,      fh*2)
    output_image:OMerge(face[2], fw, fh*3)
    output_image:OMerge(face[3], fw, fh)
    output_image:OMerge(face[4], fw, fh*2)
    output_image:OMerge(face[5]:Transform(nil, rotate), fw, 0)



  end




  if output_layout < 6 then

    output_image = face[output_layout]

  end

  OutImage:Set(req,output_image)

end
